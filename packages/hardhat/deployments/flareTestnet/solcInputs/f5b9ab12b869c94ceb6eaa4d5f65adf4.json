{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Pausable} from \"../../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/Ultimate_VotreXSystemRC2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// pragma abicoder v2;\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./UtilityLibrary.sol\";\r\nimport \"./VotreXTxInterface.sol\";\r\n\r\ncontract VotreXSystem{\r\n\r\n    using UtilityLibrary for *;\r\n\r\n    constructor(address _TXInterfaceAddress){\r\n        VotreXOwnerAddress = msg.sender;\r\n        VotreXActivated = false;\r\n        TxInterface = VotreXTXInterface(_TXInterfaceAddress);\r\n    }\r\n\r\n    VotreXTXInterface internal immutable TxInterface;\r\n    bool private VotreXActivated;\r\n    address private previousVotreXOwnerAddress;\r\n    address private VotreXOwnerAddress;\r\n    bytes32 public VotreXOwnerName = keccak256(abi.encode(\"ATom\"));\r\n    uint256 private organizationsCounter;\r\n    uint256 private VotreXUserCounter;\r\n    uint256 private OrganizationPriceFee = 20 ether;\r\n    \r\n    mapping(string  => Organization) public organizationData;\r\n    mapping(address => ElectionAdmins) public admin;\r\n    mapping(address => Voter) public voters;\r\n    mapping(bytes32 => ElectionDetail) public electionInfo;\r\n    mapping(string  => ElectionResult) public electionResults;\r\n    mapping(bytes32 => ActiveElectionList) private activeElection;\r\n    mapping(bytes32 => bool) private electionExistanceChecks;\r\n    mapping(bytes16 => bool) private votersIDExists;\r\n    mapping(address => bool) private registeredAdmin;\r\n\r\n    enum ElectionStatus {\r\n        Preparation,\r\n        Scheduled,\r\n        Started,\r\n        Finished\r\n    }\r\n\r\n    enum OrganizationType {\r\n        Organization,\r\n        Corporate\r\n    }\r\n\r\n    struct Organization {\r\n        OrganizationType orgType;\r\n        address electionAdminAddresses;\r\n        uint256 electionEventCounter;\r\n        uint256 totalMembers;\r\n        bytes32 orgName;\r\n        string orgID;\r\n    }\r\n\r\n    struct ElectionAdmins {\r\n        bool isRegistered;\r\n        uint8 adminOrgCount;\r\n        bytes10 AdminVoterIDOrg1;\r\n        bytes10 AdminVoterIDOrg2;\r\n        address electionAdminAddress;\r\n        uint256 nextOrgCreationBlock;\r\n        bytes32 adminName;\r\n        string RegisteredOrgID1;\r\n        string RegisteredOrgID2;\r\n    }\r\n\r\n    struct ActiveElectionList{\r\n        bytes32 orgID;\r\n        bytes32 activeElectionID;\r\n    }\r\n\r\n    struct ElectionResult {\r\n        bool isPruned;\r\n        address adminAddress;\r\n        uint startTime; \r\n        uint endTime;\r\n        uint totalVoter;\r\n        bytes32 electionName;\r\n        bytes32 digitalSignature;\r\n        string registeredOrganization;\r\n        string electionWinner;\r\n        string signedBy;\r\n    }\r\n    \r\n    struct Voter{\r\n        bool isRegistered;\r\n        address VoterAddress;\r\n        bytes16 VoterIDOrg1;\r\n        bytes16 VoterIDOrg2;\r\n        string VoterName;\r\n        string RegisteredOrgID1;\r\n        string RegisteredOrgID2;\r\n        string[] participatedElectionEvents;\r\n    }\r\n\r\n    struct ElectionDetail{\r\n        ElectionStatus status;\r\n        uint8 candidateList;\r\n        bool isFinished;\r\n        bytes32 electionID;\r\n        bytes32 electionName;\r\n        uint startTime;\r\n        uint endTime;\r\n        string orgID;\r\n        CandidateDetail[] candidates;\r\n    }\r\n\r\n    struct CandidateDetail{\r\n        uint8 candidateID;\r\n        uint256 candidateVoteCount;\r\n        string candidateName;\r\n    }\r\n\r\n    modifier onlyOrgAdmin(string memory _IDParameters) {\r\n        bool isAdminRegisteredForOrg = false;\r\n        if (\r\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\r\n            ==\r\n            keccak256(abi.encodePacked(_IDParameters))\r\n            ||\r\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\r\n            ==\r\n            keccak256(abi.encodePacked(_IDParameters))\r\n        ) {\r\n            isAdminRegisteredForOrg = true;\r\n        } else if (\r\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\r\n            !=\r\n            bytes32(abi.encodePacked(_IDParameters))\r\n            ||\r\n            bytes32(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\r\n            !=\r\n            bytes32(abi.encodePacked(_IDParameters))\r\n        ) {\r\n            string memory orgID = UtilityLibrary.extractOrgId(_IDParameters);\r\n            isAdminRegisteredForOrg = true;\r\n\r\n        }\r\n\r\n        require(\r\n            isAdminRegisteredForOrg,\r\n            \"Admin not in this organization\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedMember(string memory _userElectionID) {\r\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\r\n\r\n        bool isAdminRegisteredForOrg = (\r\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\r\n            ==\r\n            keccak256(abi.encodePacked(orgID))\r\n        )||(\r\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\r\n            ==\r\n            keccak256(abi.encodePacked(orgID))\r\n        );\r\n\r\n        bool isVoterRegisteredForOrg = (\r\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\r\n            ==\r\n            keccak256(abi.encodePacked(orgID))\r\n        )||(\r\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\r\n            ==\r\n            keccak256(abi.encodePacked(orgID))\r\n        );\r\n\r\n        require(\r\n            isAdminRegisteredForOrg || isVoterRegisteredForOrg,\r\n            \"You are not an authorized member\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canCreateOrg() {\r\n        require(\r\n            block.number >= admin[msg.sender].nextOrgCreationBlock,\r\n            \"Wait for the next block to create a new org\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyVotreXOwner() {\r\n        require(\r\n            msg.sender == VotreXOwnerAddress,\r\n            \"Not the contract owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenActivated() {\r\n        require(\r\n            VotreXActivated == true,\r\n            \"System is not activated\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // event Received(address UserAddress, uint256 FLRSent);\r\n\r\n    function approveSystem(uint256 amount) external onlyVotreXOwner {\r\n        require(\r\n            amount > 0,\r\n            \"Amount can not 0\"\r\n        );\r\n\r\n        TxInterface.approveVotreX(amount);\r\n    }\r\n\r\n    function buyContract(string memory _YourName) public payable {\r\n        require(VotreXActivated == false);\r\n        require(msg.value == 12 ether, \"Please send 12 Ether\");\r\n\r\n        previousVotreXOwnerAddress = VotreXOwnerAddress;\r\n        VotreXOwnerAddress = address(0);\r\n        VotreXOwnerName = keccak256(abi.encodePacked(_YourName));\r\n\r\n        payable(previousVotreXOwnerAddress).transfer(msg.value);\r\n\r\n        previousVotreXOwnerAddress = address(0);\r\n        VotreXOwnerAddress = msg.sender;\r\n    }\r\n\r\n    function CheckTokenBalance () external view onlyVotreXOwner returns (uint256) {\r\n        return TxInterface.checkBalance(address(this));\r\n    }\r\n\r\n    function changeSystemState() external onlyVotreXOwner{\r\n        if (VotreXActivated == false) {\r\n            require(VotreXActivated == false, \"Activated!\");\r\n            VotreXActivated = true;\r\n        } else if (VotreXActivated == true) {\r\n            require(VotreXActivated == true, \"Paused!\");\r\n            VotreXActivated = false;\r\n        }\r\n    }\r\n\r\n    function setOrgPriceFee(uint256 _PriceinEther) external onlyVotreXOwner {\r\n        OrganizationPriceFee = _PriceinEther * 1 ether;\r\n    }\r\n\r\n    receive() external payable {\r\n        // emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n    function registerOrganization(\r\n        string memory _orgName,\r\n        string memory _orgID,\r\n        string memory _adminName,\r\n        OrganizationType _orgType\r\n    )\r\n        external\r\n        payable\r\n        canCreateOrg\r\n        onlyWhenActivated\r\n    {\r\n        uint8 VXTAmount = 5;\r\n        ElectionAdmins storage AdminInfo = admin[msg.sender];\r\n\r\n        require(\r\n            msg.value == OrganizationPriceFee,\r\n            \"Please send correct amount\"\r\n        );\r\n\r\n        require(\r\n            organizationsCounter < 32000,\r\n            \"Maximum Organization reached\"\r\n        );\r\n\r\n        require(\r\n            bytes32(organizationData[_orgID].orgName).length > 0,\r\n            \"Organization name is registered\"\r\n        );\r\n\r\n        require(\r\n            organizationData[_orgID].electionAdminAddresses == address(0),\r\n            \"Organization ID is registered\"\r\n        );\r\n\r\n        require(\r\n            UtilityLibrary.onlyAlphanumericCharacters(_orgID),\r\n            \"Org ID should be alphanumeric\"\r\n        );\r\n\r\n        require(\r\n            bytes(_orgName).length > 0,\r\n            \"Please fill Organization Name\"\r\n        );\r\n\r\n        require(\r\n            bytes(_orgName).length < 32,\r\n            \"Org name can't exceed 32\"\r\n        );\r\n\r\n        require(\r\n            bytes(_adminName).length > 1,\r\n            \"Admin name can't be empty\"\r\n        );\r\n\r\n        require(\r\n            bytes(_orgID).length == 3 || bytes(_orgID).length == 4,\r\n            \"Org ID should 3 or 4 characters\"\r\n        );\r\n\r\n        require(\r\n            !UtilityLibrary.containsWhitespaceCheck(_orgID),\r\n            \"spaces in Org ID not allowed\"\r\n        );\r\n\r\n        require(\r\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID1))\r\n            !=\r\n            keccak256(abi.encodePacked(_orgID))\r\n            &&\r\n            keccak256(abi.encodePacked(admin[msg.sender].RegisteredOrgID2))\r\n            !=\r\n            keccak256(abi.encodePacked(_orgID)),\r\n            \"Admin is registered in organization\"\r\n        );\r\n\r\n        Organization storage newOrg = organizationData[_orgID];\r\n        newOrg.orgID = _orgID;\r\n        newOrg.orgName = bytes32(abi.encodePacked(_orgName));\r\n        newOrg.orgType = _orgType;\r\n        newOrg.electionAdminAddresses = msg.sender;\r\n        newOrg.electionEventCounter = 0;\r\n        newOrg.totalMembers = 1;\r\n\r\n        bytes10 UniqueAdminvoterID = bytes10(abi.encodePacked(_orgID, \"-\", \"Admin\"));\r\n\r\n        if (bytes(admin[msg.sender].RegisteredOrgID1).length == 0) {\r\n            admin[msg.sender].RegisteredOrgID1 = _orgID;\r\n            admin[msg.sender].AdminVoterIDOrg1 = UniqueAdminvoterID;\r\n        } else if (bytes(admin[msg.sender].RegisteredOrgID2).length == 0) {\r\n            admin[msg.sender].RegisteredOrgID2 = _orgID;\r\n            admin[msg.sender].AdminVoterIDOrg2 = UniqueAdminvoterID;\r\n        }\r\n\r\n        AdminInfo.electionAdminAddress = msg.sender;\r\n        AdminInfo.adminName = bytes32(abi.encodePacked(_adminName));\r\n        AdminInfo.isRegistered = true;\r\n        ++AdminInfo.adminOrgCount;\r\n\r\n        registeredAdmin[msg.sender] = true;\r\n        votersIDExists[UniqueAdminvoterID] = true;\r\n\r\n        AdminInfo.nextOrgCreationBlock = 50 + block.number;\r\n\r\n        ++organizationsCounter;\r\n        ++VotreXUserCounter;\r\n\r\n        TxInterface.VotreXTx(msg.sender, VXTAmount);\r\n    }\r\n\r\n    \r\n\r\n    function registerVoter(\r\n        string memory _voterName,\r\n        string memory _orgID\r\n    )\r\n        external\r\n        payable\r\n        onlyWhenActivated\r\n    {\r\n        require(\r\n            msg.value == (OrganizationPriceFee/2)\r\n        );\r\n\r\n        Voter storage voter = voters[msg.sender];\r\n        uint8 VXTAmount = 5;\r\n        string memory uniqueVoterID = generateUniqueVoterID(_orgID);\r\n        bytes16 VoterID16 = bytes16(abi.encodePacked(uniqueVoterID));\r\n        bytes32 orgIDs = keccak256(abi.encodePacked(_orgID));\r\n\r\n        require(\r\n            organizationData[_orgID].totalMembers < 5000,\r\n            \"Maximum member limit reached\"\r\n        );\r\n\r\n        require(\r\n            bytes(_voterName).length > 1,\r\n            \"Please fill Voter Name\"\r\n        );\r\n\r\n        require(\r\n            bytes(_voterName).length < 24,\r\n            \"Voter name over than 24 characters\"\r\n        );\r\n\r\n        require(\r\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID1))\r\n            !=\r\n            keccak256(abi.encodePacked(_orgID))\r\n            &&\r\n            keccak256(abi.encodePacked(voters[msg.sender].RegisteredOrgID2))\r\n            !=\r\n            keccak256(abi.encodePacked(_orgID))\r\n            &&\r\n            !registeredAdmin[msg.sender],\r\n            \"Voter is registered in Org\"\r\n        );\r\n\r\n        require(\r\n            !ElectionActiveCheck(orgIDs),\r\n            \"Election in progress!\"\r\n        );\r\n\r\n        require(\r\n            bytes(uniqueVoterID).length > 0,\r\n            \"Failed to generate unique Voter ID\"\r\n        );\r\n\r\n        if (bytes(voter.RegisteredOrgID1).length == 0) {\r\n            voter.RegisteredOrgID1 = _orgID;\r\n            voter.VoterIDOrg1 = VoterID16;\r\n        } else if (bytes(voter.RegisteredOrgID2).length == 0) {\r\n            voter.RegisteredOrgID2 = _orgID;\r\n            voter.VoterIDOrg2 = VoterID16;\r\n        }\r\n\r\n        voter.VoterAddress = msg.sender;\r\n        voter.VoterName = _voterName;\r\n        voter.participatedElectionEvents = new string[](0);\r\n        voter.isRegistered = true;\r\n        votersIDExists[VoterID16] = true;\r\n        ++VotreXUserCounter;\r\n\r\n        TxInterface.VotreXTx(msg.sender, VXTAmount);\r\n    }\r\n\r\n    function createElection(\r\n        string memory _orgID,\r\n        string memory _userElectionID,\r\n        string memory _electionName,\r\n        uint8 _candidateCount\r\n    )\r\n        external\r\n        onlyWhenActivated\r\n        onlyOrgAdmin(_orgID)\r\n    {\r\n        require(\r\n            bytes(organizationData[_orgID].orgID).length > 0,\r\n            \"Org ID not found\"\r\n        );\r\n\r\n        require(\r\n            bytes(_userElectionID).length > 1,\r\n            \"ID can't be empty\"\r\n        \r\n        );\r\n\r\n        require(\r\n            bytes(_userElectionID).length < 5,\r\n            \"ID should < 5 characters\"\r\n        );\r\n\r\n        require(\r\n            bytes(_electionName).length > 1,\r\n            \"Please fill name\"\r\n        );\r\n\r\n        require(\r\n            bytes(_electionName).length < 25,\r\n            \"Election name should < 25\"\r\n        );\r\n\r\n        require(\r\n            organizationData[_orgID].electionEventCounter < 10,\r\n            \"Maximum events reached\"\r\n        );\r\n\r\n        require(_candidateCount > 1, \"Minimum 2 candidates!\");\r\n\r\n        bytes32 generatedElectionID = bytes32(abi.encodePacked(_orgID, \"-\", _userElectionID));\r\n        ElectionDetail storage newElection = electionInfo[generatedElectionID];\r\n\r\n        require(\r\n            !electionExistanceChecks[generatedElectionID],\r\n            \"Election ID exists\"\r\n        );\r\n\r\n        newElection.orgID = _orgID;\r\n        newElection.electionID = generatedElectionID;\r\n        newElection.electionName = bytes32(abi.encodePacked(_electionName));\r\n        newElection.candidateList = _candidateCount;\r\n        newElection.status = ElectionStatus.Preparation;\r\n        electionExistanceChecks[generatedElectionID] = true;\r\n        ++organizationData[_orgID].electionEventCounter;\r\n    }\r\n\r\n    function startElection(string memory _userElectionID) external onlyOrgAdmin(_userElectionID){\r\n        require(bytes(_userElectionID).length > 0, \"Election ID can't be empty\");\r\n\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n        bytes32 orgIDs = keccak256(abi.encodePacked(UtilityLibrary.extractOrgId(_userElectionID)));\r\n\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n        require(bytes16(election.electionID).length > 0, \"Election ID does not exist\");\r\n        require(election.status == ElectionStatus.Preparation, \"Election is not in preparation\");\r\n        require(election.candidateList == election.candidates.length, \"Candidate Not full\");\r\n\r\n        election.startTime = 5 + block.timestamp;\r\n        election.status = ElectionStatus.Started;\r\n        activeElection[orgIDs].orgID = orgIDs;\r\n        activeElection[orgIDs].activeElectionID = userElectionID;\r\n    }\r\n\r\n    function finishElection(string memory _userElectionID)\r\n        external\r\n        onlyOrgAdmin(_userElectionID)\r\n    {\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n        ElectionDetail storage elections = electionInfo[userElectionID];\r\n        string memory orgName = string(abi.encodePacked(organizationData[elections.orgID].orgName));\r\n        bytes32 orgIDs = keccak256(abi.encodePacked(UtilityLibrary.extractOrgId(_userElectionID)));\r\n        string memory adminName = getAdminName(msg.sender);\r\n        string memory electionName = string(abi.encodePacked(elections.electionName));\r\n        string memory electionWinner = determineWinner(_userElectionID);\r\n        uint256 totalVoter = calculateTotalVoter(_userElectionID);\r\n        bytes32 dataHash = bytes32(keccak256(abi.encodePacked(orgName, electionName, adminName)));\r\n\r\n        require(\r\n            bytes(_userElectionID).length > 0,\r\n            \"Invalid election ID\"\r\n        );\r\n\r\n        require(\r\n            bytes(_userElectionID).length > 0,\r\n            \"Election ID can't be empty\"\r\n        );\r\n\r\n        require(\r\n            bytes32(electionInfo[userElectionID].electionID).length > 0,\r\n            \"Election ID does not exist\"\r\n        );\r\n\r\n        require(!elections.isFinished, \"Election finished\");\r\n\r\n        require(\r\n            elections.status == ElectionStatus.Started,\r\n            \"Election is not started\"\r\n        );\r\n\r\n        require(\r\n            totalVoter >= calculateValidElection(_userElectionID),\r\n            \"need 50% total member to finish\"\r\n        );\r\n\r\n        elections.endTime = 5+block.timestamp;\r\n        elections.status = ElectionStatus.Finished;\r\n        elections.isFinished = true;\r\n\r\n        ElectionResult storage newelectionResult = electionResults[_userElectionID];\r\n        newelectionResult.isPruned = true;\r\n        newelectionResult.totalVoter = totalVoter;\r\n        newelectionResult.adminAddress = msg.sender;\r\n        newelectionResult.startTime = elections.startTime;\r\n        newelectionResult.endTime = elections.endTime;\r\n        newelectionResult.digitalSignature = dataHash;\r\n        newelectionResult.registeredOrganization = elections.orgID;\r\n        newelectionResult.electionName = elections.electionName;\r\n        newelectionResult.electionWinner = electionWinner;\r\n        newelectionResult.signedBy = adminName;\r\n        removeFromActiveElections(orgIDs);\r\n\r\n        delete electionInfo[userElectionID];\r\n    }\r\n\r\n    function calculateValidElection(string memory _userElectionID)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        string memory orgID = UtilityLibrary.extractOrgId(_userElectionID);\r\n        Organization storage OrgData = organizationData[orgID];\r\n        uint256 MIN_VOTES_PERCENTAGE = 1 + (OrgData.totalMembers / 2);\r\n\r\n        return MIN_VOTES_PERCENTAGE;\r\n    }\r\n\r\n    function getOwnerAddress() external view returns (address) {\r\n        return VotreXOwnerAddress;\r\n    }\r\n\r\n    function getOwnerName() external view returns (bytes32) {\r\n        return VotreXOwnerName;\r\n    }\r\n\r\n    // function getTotalOrg()external view returns (uint256) {\r\n    //     return organizationsCounter;\r\n    // }\r\n\r\n    function getTotalUser() external view returns (uint256) {\r\n        return VotreXUserCounter;\r\n    }\r\n\r\n    function getAdminName(address adminAddress) private view returns (string memory) {\r\n        return string(abi.encodePacked(admin[adminAddress].adminName));\r\n    }\r\n\r\n    function addCandidateDetail(\r\n        string memory _userElectionID,\r\n        string memory _candidateName\r\n    )\r\n        external\r\n        onlyOrgAdmin(_userElectionID)\r\n    {\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n\r\n        require(bytes(_userElectionID).length > 0);\r\n\r\n        require(\r\n            bytes32(electionInfo[userElectionID].electionID).length > 0,\r\n            \"Election ID does not exist\"\r\n        );\r\n\r\n        require(\r\n            election.candidates.length < election.candidateList,\r\n            \"Candidate limit reached\"\r\n        );\r\n\r\n        require(bytes(_candidateName).length > 0);\r\n\r\n        require(\r\n            bytes(_candidateName).length <= 24,\r\n            \"name limits 24 characters\"\r\n        );\r\n\r\n        require(\r\n            UtilityLibrary.onlyAlphanumericCharacters(_candidateName),\r\n            \"Candidate name can only contain alphabetical\"\r\n        );\r\n\r\n        uint8 candidateID = uint8(election.candidates.length);\r\n\r\n        election.candidates.push(\r\n            CandidateDetail({\r\n                candidateID: candidateID,\r\n                candidateName: _candidateName,\r\n                candidateVoteCount: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    function vote(\r\n        string memory _userElectionID,\r\n        uint8 candidateID, uint256 VotesAmount\r\n    )\r\n        external\r\n        onlyWhenActivated\r\n        onlyAuthorizedMember(_userElectionID)\r\n    {\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n        Voter storage voter = voters[msg.sender];\r\n        bytes32 electionName = election.electionName;\r\n        require(VotesAmount <= 5);\r\n        require(bytes(_userElectionID).length > 0, \"Election ID can't be empty\");\r\n        require(candidateID < election.candidates.length, \"Invalid candidate ID\");\r\n        require(election.status == ElectionStatus.Started, \"Election is not in progress\");\r\n        require(!hasParticipatedInElection(msg.sender, electionName), \"You already voted in this election\");\r\n\r\n        ++election.candidates[candidateID].candidateVoteCount;\r\n        election.candidates[candidateID].candidateVoteCount += VotesAmount;\r\n        voter.participatedElectionEvents = UtilityLibrary.appendToStringArray(\r\n            voter.participatedElectionEvents,\r\n            string(abi.encodePacked(election.electionName))\r\n        );\r\n        TxInterface.VoteTx(msg.sender, VotesAmount);\r\n    }\r\n\r\n\r\n    function withdrawFees(uint8 VXTAmount) external onlyVotreXOwner{\r\n        payable(VotreXOwnerAddress).transfer(address(this).balance);\r\n        TxInterface.VotreXTx(msg.sender, VXTAmount);\r\n    }\r\n\r\n    function isVotreXActivated() external onlyVotreXOwner view returns (bool) {\r\n        return VotreXActivated;\r\n    }\r\n\r\n    function getRegistrationFee() external view returns (uint256){\r\n        return OrganizationPriceFee;\r\n    }\r\n\r\n    // function getTotalOrganization() external virtual view returns (uint256) {\r\n    //     return organizationsCounter;\r\n    // }\r\n\r\n    function getCandidateDetail(\r\n        string memory _userElectionID,\r\n        string memory _candidateName\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bool success,\r\n            string memory candidateName,\r\n            uint8 candidateID,\r\n            uint256 voteCount\r\n        )\r\n    {\r\n        require(\r\n            bytes(_userElectionID).length > 0,\r\n            \"Election ID can't be empty\"\r\n        );\r\n\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n\r\n        for (uint32 i = 0; i < election.candidates.length; ++i) {\r\n            if (\r\n                keccak256(abi.encodePacked(election.candidates[i].candidateName))\r\n                ==\r\n                keccak256(abi.encodePacked(_candidateName))\r\n            ) {\r\n                return (\r\n                    true,\r\n                    election.candidates[i].candidateName,\r\n                    election.candidates[i].candidateID,\r\n                    election.candidates[i].candidateVoteCount\r\n                );\r\n            }\r\n        }\r\n\r\n        return (false,'', 0, 0);\r\n\r\n    }\r\n\r\n    function getelectionInfo(string memory _userElectionID)\r\n        external\r\n        view\r\n        returns(\r\n            bytes32 electionID,\r\n            string memory electionName,\r\n            uint256 totalCandidates,\r\n            string[] memory candidateNames,\r\n            uint[] memory voteCounts\r\n        )\r\n    {\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n        require(\r\n            bytes32(election.electionID).length > 0,\r\n            \"Election ID does not exist\"\r\n        );\r\n\r\n        electionID = election.electionID;\r\n        electionName = string(abi.encodePacked (election.electionName));\r\n        totalCandidates = election.candidates.length;\r\n        candidateNames = new string[](totalCandidates);\r\n        voteCounts = new uint[](totalCandidates);\r\n\r\n        for (uint256 i = 0; i < totalCandidates; ++i) {\r\n            candidateNames[i] = election.candidates[i].candidateName;\r\n            voteCounts[i] = election.candidates[i].candidateVoteCount;\r\n        }\r\n\r\n        return (\r\n            electionID,\r\n            electionName,\r\n            totalCandidates,\r\n            candidateNames, voteCounts\r\n        );\r\n    }\r\n\r\n    function getCurrentVoteResult(string memory _userElectionID)\r\n        external\r\n        view\r\n        returns (\r\n            CandidateDetail[] memory\r\n        )\r\n    {\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n\r\n        require(bytes(_userElectionID).length > 0, \"Election ID can't be empty\");\r\n\r\n        require(election.status == ElectionStatus.Started, \"Election is not in progress\");\r\n\r\n        return election.candidates;\r\n    }\r\n\r\n    function getUserInfo() external view returns (\r\n        bool isRegistered,\r\n        address userAddress,\r\n        string memory userName,\r\n        string[] memory registeredOrgList,\r\n        string[] memory voterIDList,\r\n        string[] memory participatedElectionEvents\r\n    ) {\r\n        userAddress = msg.sender;\r\n\r\n        if (admin[userAddress].isRegistered) {\r\n            ElectionAdmins storage adminInfo = admin[userAddress];\r\n            \r\n            string[] memory VoterRegisteredOrgList = new string[](2);\r\n            VoterRegisteredOrgList[0] = adminInfo.RegisteredOrgID1;\r\n            VoterRegisteredOrgList[1] = adminInfo.RegisteredOrgID2;\r\n\r\n            string[] memory VoterIDList = new string[](2);\r\n            VoterIDList[0] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg1));\r\n            VoterIDList[1] = string(abi.encodePacked(adminInfo.AdminVoterIDOrg2));\r\n\r\n            return (\r\n                true,\r\n                userAddress,\r\n                string(abi.encodePacked(adminInfo.adminName)),\r\n                VoterRegisteredOrgList,\r\n                VoterIDList,\r\n                new string[](0)\r\n            );\r\n\r\n        } else if (voters[userAddress].isRegistered) {\r\n            Voter storage voter = voters[userAddress];\r\n\r\n            string[] memory RegisteredOrgIDList = new string[](2);\r\n            RegisteredOrgIDList[0] = voter.RegisteredOrgID1;\r\n            RegisteredOrgIDList[1] = voter.RegisteredOrgID2;\r\n\r\n            string[] memory RegisteredVoterIDList = new string[](2);\r\n            RegisteredVoterIDList[0] = string(abi.encodePacked(voter.VoterIDOrg1));\r\n            RegisteredVoterIDList[1] = string(abi.encodePacked(voter.VoterIDOrg2));\r\n            return (\r\n                true,\r\n                userAddress,\r\n                voter.VoterName,\r\n                RegisteredOrgIDList,\r\n                RegisteredVoterIDList,\r\n                voter.participatedElectionEvents\r\n            );\r\n        } else {\r\n            return (\r\n                false,\r\n                userAddress,\r\n                \"\",\r\n                new string[](0),\r\n                new string[](0),\r\n                new string[](0)\r\n            );\r\n        }\r\n    }\r\n\r\n    function ElectionActiveCheck(bytes32 _orgID) private view returns (bool) {\r\n\r\n        return activeElection[_orgID].activeElectionID != 0;\r\n\r\n    }\r\n\r\n    function removeFromActiveElections(bytes32 _orgID) private {\r\n        delete activeElection[_orgID];\r\n    }\r\n\r\n    function hasParticipatedInElection(\r\n        address voterAddress,\r\n        bytes32 electionName\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        Voter storage voter = voters[voterAddress];\r\n        for (uint i = 0; i < voter.participatedElectionEvents.length; ++i) {\r\n            if (\r\n                keccak256(abi.encodePacked(voter.participatedElectionEvents[i]))\r\n                ==\r\n                keccak256(abi.encodePacked(electionName))\r\n            ) {\r\n                return true; \r\n            }\r\n        }\r\n\r\n        return false; \r\n    }\r\n\r\n    function calculateTotalVoter(string memory _userElectionID) private view returns (uint256) {\r\n        bytes8 userElectionID = bytes8(abi.encodePacked(_userElectionID));\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n        uint256 totalVoter = 0;\r\n\r\n        for (uint8 i = 0; i < election.candidates.length; ++i) {\r\n            totalVoter += election.candidates[i].candidateVoteCount;\r\n        }\r\n\r\n        return totalVoter;\r\n    }\r\n\r\n    function determineWinner(string memory _userElectionID) private view returns (string memory) {\r\n        bytes32 userElectionID = bytes32(abi.encodePacked(_userElectionID));\r\n        ElectionDetail storage election = electionInfo[userElectionID];\r\n        string memory winner = \"\";\r\n        uint256 maxVotes = 0;\r\n        for (uint8 i = 0; i < election.candidates.length; ++i) {\r\n            if (election.candidates[i].candidateVoteCount > maxVotes) {\r\n                maxVotes = election.candidates[i].candidateVoteCount;\r\n                winner = election.candidates[i].candidateName;\r\n            }\r\n        }\r\n\r\n        return winner;\r\n    }\r\n    \r\n    function generateUniqueVoterID(string memory _orgID) public view returns (string memory) {\r\n        uint256 CurrentID = organizationData[_orgID].totalMembers;\r\n        uint256 nextID = ++CurrentID;\r\n\r\n        return string(abi.encodePacked(_orgID, \"-\", UtilityLibrary.uint2str(nextID)));\r\n    }\r\n\r\n    function getOrgIDHash(string memory _orgID) external pure returns (bytes32) {\r\n        bytes32 orgIDHash = keccak256(abi.encodePacked(_orgID));\r\n\r\n        return (orgIDHash);\r\n    }\r\n}\r\n"
    },
    "contracts/UtilityLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >0.7.0;\r\n\r\nlibrary UtilityLibrary{\r\n\r\n    function extractOrgId(string memory _userElectionID) internal pure returns (string memory) {\r\n        string[] memory parts = UtilityLibrary.splitString(_userElectionID, \"-\");\r\n        require(parts.length > 0, \"Invalid custom election ID format\");\r\n\r\n        return parts[0];\r\n    }\r\n\r\n    function decodeBytes10(bytes10 data) internal pure returns (string memory) {\r\n        string memory decodedString = new string(10);\r\n        \r\n        assembly {\r\n            mstore(add(decodedString, 32), data)\r\n        }\r\n\r\n        return decodedString;\r\n    }\r\n    \r\n    function arrayContains(string[] storage array, string memory element) internal view returns (bool) {\r\n        for (uint256 i = 0; i < array.length; ++i) {\r\n            if (keccak256(abi.encodePacked(array[i])) == keccak256(abi.encodePacked(element))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function onlyAlphanumericCharacters(string memory _input) internal pure returns (bool) {\r\n        bytes memory b = bytes(_input);\r\n        for (uint i = 0; i < b.length; ++i) {\r\n            if (!((uint8(b[i]) >= 48 && uint8(b[i]) <= 57) || // 0-9\r\n                (uint8(b[i]) >= 65 && uint8(b[i]) <= 90) || // A-Z\r\n                (uint8(b[i]) >= 97 && uint8(b[i]) <= 122))) { // a-z\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function appendToStringArray(string[] memory array, string memory newValue) internal pure returns (string[] memory) {\r\n        string[] memory newArray = new string[](array.length + 1);\r\n        \r\n        for (uint32 i = 0; i < array.length; ++i) {\r\n            newArray[i] = array[i];\r\n        }\r\n        \r\n        newArray[array.length] = newValue;\r\n        \r\n        return newArray;\r\n    }\r\n\r\n    function containsWhitespaceCheck(string memory _str) internal pure returns (bool) {\r\n        bytes memory strBytes = bytes(_str);\r\n\r\n        for (uint256 i = 0; i < strBytes.length; ++i) {\r\n            if (strBytes[i] == \" \") {\r\n                return true; \r\n            }\r\n        }\r\n\r\n        return false; \r\n    }\r\n\r\n\r\n    function uintToString(uint48 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        uint48 temp = value;\r\n        uint48 length;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp /= 10;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(length);\r\n        uint48 i = length - 1;\r\n        while (value != 0) {\r\n            buffer[i] = bytes1(uint8(48 + value % 10));\r\n            value /= 10;\r\n            i--;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            ++len;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)));\r\n    }\r\n\r\n    function splitString(string memory str, string memory delimiter) internal pure returns (string[] memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory delimiterBytes = bytes(delimiter);\r\n\r\n        uint delimiterCount = 1;\r\n        for (uint i = 0; i < strBytes.length; ++i) {\r\n            if (strBytes[i] == delimiterBytes[0]) {\r\n                ++delimiterCount;\r\n            }\r\n        }\r\n\r\n        string[] memory parts = new string[](delimiterCount);\r\n\r\n        uint partStart = 0;\r\n        uint partIndex = 0;\r\n        for (uint i = 0; i < strBytes.length; ++i) {\r\n            if (strBytes[i] == delimiterBytes[0]) {\r\n                parts[partIndex] = substring(str, partStart, i);\r\n                partStart = i + 1;\r\n                partIndex++;\r\n            }\r\n        }\r\n\r\n        // Add the last part\r\n        parts[partIndex] = substring(str, partStart, strBytes.length);\r\n\r\n        return parts;\r\n    }\r\n\r\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        require(startIndex <= endIndex && endIndex <= strBytes.length, \"Invalid substring indices\");\r\n\r\n        bytes memory result = new bytes(endIndex - startIndex);\r\n        for (uint i = startIndex; i < endIndex; ++i) {\r\n            result[i - startIndex] = strBytes[i];\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n\r\n    function extractOrgIdFromElectionId(string memory _userElectionID) internal pure returns (string memory) {\r\n        bytes memory orgIdBytes = bytes(_userElectionID);\r\n\r\n        // Split the input string at the hyphen ('-')\r\n        uint8 i = 0;\r\n        while (i < orgIdBytes.length && orgIdBytes[i] != '-'){  // ASCII code for hyphen '-'\r\n            ++i;\r\n        }\r\n\r\n        // If a hyphen is found, extract the organization ID\r\n        if (i < orgIdBytes.length) {\r\n            bytes memory extractedBytes = new bytes(i);\r\n            for (uint8 j = 0; j < i; ++j) {\r\n                extractedBytes[j] = orgIdBytes[j];\r\n            }\r\n            return string(extractedBytes);\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    function concat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(bytes(_a), bytes(_b)));\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/VotreXDex.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n// import \"./VotreXToken.sol\";\nimport \"./VotreXTxInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VotreXDex {\n    using SafeMath for uint256;\n\n    constructor(address _intefaceAddress){\n        vxtInterface = VotreXTXInterface(_intefaceAddress);\n        ContractOwner = msg.sender;\n    }\n\n    VotreXTXInterface public immutable vxtInterface;\n    address public immutable ContractOwner;\n    uint256 public VXPriceRequested;\n    uint256 private FLRPricePoint;\n\n    mapping(address => uint256) public allowances;\n\n    event BuyVXTEvent (address indexed Requester,  uint256 FLRSent, uint256 VXTAmount);\n\n    modifier onlyOwner() {\n        require(msg.sender == ContractOwner, \"Caller is not a staker\");\n        _;\n    }\n\n    function addVXTPricingFLR(uint256 _flrPrice) public {\n        uint256 PricingConversion = _flrPrice * 1 ether;\n        FLRPricePoint = PricingConversion;\n    }\n\n    function approveDeX(uint256 amount) external onlyOwner {\n        require(msg.sender != address(0), \"DeX Address not set\");\n        vxtInterface.approveDeX(amount);\n        allowances[address(this)] = amount * 10 ** 18;\n    }\n\n    function checkFLR(uint256 _FLRAmount) public pure returns(uint256) {\n        uint256 VXT = _FLRAmount * 1 ether;\n\n        return VXT;\n    }\n\n    function convertToVXT(uint256 _VXTAmount) public pure returns(uint256) {\n        uint256 VXT = _VXTAmount.mul(10**18);\n\n        return VXT;\n    }\n\n    function GetVXTtoFLRPrice() public view returns(uint256) {\n\n        return FLRPricePoint;\n    }\n\n    function calculateReqPricesFLR(uint256 ETHAmount) public view returns (uint256 FLRAmount, uint256 VXTAmount) {\n        uint256 SentFLR = ETHAmount.mul(1 ether);\n        uint256 vxtCheckout = SentFLR.div(FLRPricePoint);\n        uint256 vxtNominal = vxtCheckout;\n\n        return (SentFLR, vxtNominal);\n    }\n\n    receive() external payable {\n        // emit Received(msg.sender, msg.value);\n    }\n\n    function BuyVXT() external payable {\n        uint256 SentFLR = msg.value.mul(1 ether);\n        uint256 vxtCheckout = SentFLR.div(FLRPricePoint);\n\n        require(msg.value > FLRPricePoint.div(2), \"Not sending at minimum reqirement\");\n        require(msg.value > 0, \"Ether value can't 0\");\n        \n        vxtInterface.VotreXTx(msg.sender, vxtCheckout);\n        allowances[msg.sender] = vxtCheckout;\n\n        emit BuyVXTEvent(msg.sender, msg.value, vxtCheckout);\n    }\n\n    function withdrawBalance() external onlyOwner{\n        require(address(this).balance != 0 ether, \"No FLR Left\");\n        uint256 withdrawalValue = address(this).balance;\n        payable(ContractOwner).transfer(withdrawalValue);\n    }\n\n    function CheckTokenBalance () external view onlyOwner returns (uint256) {\n        uint256 contractBalance = vxtInterface.checkBalance(address(this));\n        return contractBalance;\n    }\n    \n    function withdrawToken() external onlyOwner{\n        uint256 contractBalance = vxtInterface.checkBalance(address(this));\n        require(contractBalance > 0, \"No Token left\");\n        vxtInterface.VotreXTx(payable(msg.sender), contractBalance);\n    }\n\n\n}\n"
    },
    "contracts/VotreXStaker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"./VotreXToken.sol\";\nimport \"./VotreXTxInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VotreXStake {\n    using SafeMath for uint256;\n\n    constructor(address _intefaceAddress){\n        VXInterface = VotreXTXInterface(_intefaceAddress);\n        Owner = msg.sender;\n    }\n\n    VotreXTXInterface private VXInterface;\n\n    uint8 private constant STAKE_REWARD_PERCENTAGE = 5;\n    uint256 private constant EPOCH_DURATION = 15 minutes;\n\n    address private immutable Owner;\n    address private Automation;\n    address[] private Stakeraddress;\n\n    uint256 private totalStake;\n    uint256 private sharedRewards;\n    uint256 private totalPrintToken;\n    uint256 private accumulativePrintedToken;\n    uint256 private totalInitialRewards;\n\n    mapping(address => StakerStorage) public stakerInfo;\n    mapping(address => uint256) public allowances;\n\n\n    struct StakerStorage{\n        address StakerAddress;\n        uint256 StakingValue;\n        uint256 initialReward;\n        uint256 accumulativeReward;\n        uint256 totalPrintedToken;\n        uint256 PrintValue;\n        uint256 startStakingTime;\n        uint256 rewardTime;\n    }\n\n    event Staked(\n        address indexed staker,\n        uint256 stakeValue,\n        uint256 rewardPercentage,\n        uint256 rewardValue,\n        uint256 StartTime,\n        uint256 NextRewardTime\n    );\n\n    event TokenPrinted(\n        address indexed Destination,\n        uint256 printedValue\n    );\n\n    event Unstaked(\n        address indexed staker,\n        uint256 stakeValueTaken\n    );\n\n    modifier onlyStaker() {\n        require(msg.sender == stakerInfo[msg.sender].StakerAddress, \"Caller is not a staker\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == Owner, \"Caller is not Owner\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            msg.sender == Owner\n            ||\n            msg.sender == Automation\n            ||\n            msg.sender == address(this),\n            \"Caller is not an Authorized\"\n        );\n        _;\n    }\n\n    function setNewInterfaceAddress (address _interfaceAddress) external onlyOwner{\n        require(\n            _interfaceAddress != address(VXInterface),\n            \"Registered Interface\"\n        );\n\n        require(\n            _interfaceAddress != address(0),\n            \"Invalid contract address\"\n        );\n\n        VXInterface = VotreXTXInterface(_interfaceAddress);\n    }\n\n    function authorizeAutomation(address _AutomationAddress) public onlyOwner{\n        Automation = _AutomationAddress;\n    }\n\n    function approveStaking(uint256 amount) external onlyOwner {\n        require(msg.sender != address(0), \"Invalid Address\");\n        VXInterface.approveStaking(amount);\n        allowances[address(this)] = amount * 10 ** 18;\n    }\n\n    function CheckTokenBalance() external view onlyOwner returns (uint256) {\n        uint256 cotractBalance = VXInterface.checkBalance(address(this));\n        return cotractBalance;\n    }\n    \n    function withdrawTokentoOwner() external onlyOwner {\n        uint256 contractBalance = VXInterface.checkBalance(address(this));\n        uint256 withdrawalValue = contractBalance - totalStake;\n        uint256 withdrawalsLimit = totalStake;\n        require(totalPrintToken > 0, \"Token is empty\");\n        require(contractBalance > withdrawalsLimit, \"Withdrawal Limit Reached\");\n\n        VXInterface.VotreXTx(msg.sender, withdrawalValue);\n    }\n\n    function withdrawPrintedTokento(address _destination) external onlyOwner{\n        uint256 withdrawalValue = accumulativePrintedToken - totalInitialRewards;\n        uint256 contractBalance = VXInterface.checkBalance(address(this));\n        uint256 withdrawalsLimit = totalStake;\n        require(totalPrintToken > 0, \"Token is empty\");\n        require(contractBalance > withdrawalsLimit, \"Withdrawal Limit Reached\");\n\n        VXInterface.VotreXTx(_destination, withdrawalValue);\n    }\n\n    function stake(uint256 stakeVXTValue) public {\n        require(stakeVXTValue > 0, \"Stake value must be greater than 0\");\n        require(stakeVXTValue > 500, \"Minimum stake is 500 VXT\");\n        require(stakeVXTValue < 4000000, \"Maximum stake is 4.000.0000 VXT\");\n        require(stakerInfo[msg.sender].StakingValue == 0, \"You already on staked phase\");\n\n        uint256 stakeValue = stakeVXTValue * 10**18;\n        uint256 startTime = 10 seconds+block.timestamp;\n        uint256 nextRewardTime = calculateNextTimeReward(startTime);\n        uint256 rewardValue = calculateRewardValue(stakeValue);\n        uint256 PrintValue = calculatePrintValue(stakeValue);\n\n        VXInterface.Stake(true, msg.sender, stakeValue);\n\n        stakerInfo[msg.sender] = StakerStorage(\n            msg.sender,\n            stakeValue,\n            rewardValue,\n            0,\n            0,\n            PrintValue,\n            startTime,\n            nextRewardTime\n        );\n\n        totalPrintToken += PrintValue;\n        Stakeraddress.push(msg.sender);\n        totalStake += stakeValue;\n        totalInitialRewards += rewardValue;\n        emit Staked(\n            msg.sender,\n            stakeValue,\n            STAKE_REWARD_PERCENTAGE,\n            stakerInfo[msg.sender].initialReward,\n            startTime,\n            nextRewardTime\n        );\n    }\n\n    function unstake() public onlyStaker {\n        uint256 initialStake = stakerInfo[msg.sender].StakingValue;\n        require(initialStake > 0, \"No stake to unstake\");\n\n        VXInterface.Stake(false, msg.sender, initialStake);\n\n        uint256 stakerIndex = findStakerIndex(msg.sender);\n        require(stakerIndex < Stakeraddress.length, \"Staker not found\");\n\n        if (stakerIndex < Stakeraddress.length - 1) {\n            Stakeraddress[stakerIndex] = Stakeraddress[Stakeraddress.length - 1];\n        }\n        Stakeraddress.pop();\n        totalStake -= initialStake;\n        sharedRewards -= stakerInfo[msg.sender].initialReward;\n        totalPrintToken -= stakerInfo[msg.sender].PrintValue;\n        accumulativePrintedToken -= stakerInfo[msg.sender].accumulativeReward;\n        totalInitialRewards -= stakerInfo[msg.sender].initialReward;\n\n        delete stakerInfo[msg.sender].StakerAddress;\n        delete stakerInfo[msg.sender].StakingValue;\n        delete stakerInfo[msg.sender].initialReward;\n        delete stakerInfo[msg.sender].accumulativeReward;\n        delete stakerInfo[msg.sender].totalPrintedToken;\n        delete stakerInfo[msg.sender].PrintValue;\n        delete stakerInfo[msg.sender].startStakingTime;\n        delete stakerInfo[msg.sender].rewardTime;\n\n        emit Unstaked(msg.sender, initialStake);\n    }\n\n    function checkTotalStakes() external view returns (uint256) {\n\n        return totalStake;\n    }\n\n    function checksharedRewards() external view returns (uint256) {\n\n        return sharedRewards;\n    }\n\n    function checkTotalPrintToken() external view returns (uint256) {\n\n        return totalPrintToken;\n    }\n\n    function checkTotalInitialRewards() external view returns (uint256) {\n\n        return totalInitialRewards;\n    }\n\n    function findStakerIndex(address stakerAddress) internal view returns (uint256) {\n        for (uint256 i = 0; i < Stakeraddress.length; i++) {\n            if (Stakeraddress[i] == stakerAddress) {\n                return i;\n            }\n        }\n        return Stakeraddress.length;\n    }\n\n    function distributeRewards() external onlyAuthorized {\n        address[] memory stakersToReward = filterStakers();\n\n        require(stakersToReward.length > 0, \"No staker to reward\");\n\n        for (uint256 i = 0; i < stakersToReward.length; i++) {\n            address staker = stakersToReward[i];\n            uint256 PrintedToken = stakerInfo[staker].PrintValue;\n            uint256 reward = stakerInfo[staker].initialReward;\n\n            printToken(PrintedToken);\n            VXInterface.Stake(false, staker, reward);\n\n            stakerInfo[staker].accumulativeReward += stakerInfo[staker].initialReward;\n            stakerInfo[staker].rewardTime = 10 seconds + block.timestamp + EPOCH_DURATION;\n            sharedRewards += reward;\n            accumulativePrintedToken += PrintedToken;\n            stakerInfo[staker].totalPrintedToken += PrintedToken;\n        }\n    }\n\n    function calculateNextTimeReward(uint256 _startTime) internal pure returns (uint256) {\n        uint256 NextTime = _startTime + EPOCH_DURATION;\n        return NextTime;\n\n    }\n\n    function printToken(uint256 _rewardValue) internal onlyAuthorized{\n        require(_rewardValue > 0, \"No reward to claim\");\n        VXInterface.printVXT(address(this), _rewardValue);\n\n        emit TokenPrinted(address(this), _rewardValue);\n    }\n\n    function filterStakers() private view returns (address[] memory) {\n        uint256 currentTime = block.timestamp;\n        uint256 stakerCount = Stakeraddress.length;\n        uint256 rewardsCount = 0;\n\n        for (uint256 i = 0; i < stakerCount; ++i) {\n            address staker = Stakeraddress[i];\n            if (currentTime >= stakerInfo[staker].rewardTime) {\n                ++rewardsCount;\n            }\n        }\n\n        address[] memory stakersToReward = new address[](rewardsCount);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < stakerCount; ++i) {\n            address staker = Stakeraddress[i];\n            if (currentTime >= stakerInfo[staker].rewardTime) {\n                stakersToReward[index] = staker;\n                ++index;\n            }\n        }\n\n        return stakersToReward;\n    }\n\n    function calculateRewardValue(uint256 stakeValue) private pure returns (uint256) {\n\n        return calculatePrintValue(stakeValue).mul(STAKE_REWARD_PERCENTAGE).div(100);\n    }\n\n    function calculatePrintValue(uint256 stakeValue) private pure returns (uint256) {\n\n        return stakeValue.mul(15).div(100);\n    }\n\n    function getStakerRewardTimes() public view returns (address[] memory stakerAddressList, uint256[] memory rewardTimeList) {\n        uint256 stakerCount = Stakeraddress.length;\n        stakerAddressList = new address[](stakerCount);\n        rewardTimeList = new uint256[](stakerCount);\n\n        for (uint256 i = 0; i < stakerCount; i++) {\n            address staker = Stakeraddress[i];\n            stakerAddressList[i] = staker;\n            rewardTimeList[i] = stakerInfo[staker].rewardTime;\n        }\n\n        return (stakerAddressList, rewardTimeList);\n    }\n\n\n}\n"
    },
    "contracts/VotreXToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\n\ncontract VotreXToken is ERC20, ERC20Burnable, ERC20Pausable {\n    constructor(uint256 _initialMintedToken, uint256 _MaxSupplies)\n        ERC20(\"VotreXToken\", \"VOX\")\n    {\n        Owner = msg.sender;\n        MAXSupply = _MaxSupplies * 10 ** decimals();\n        _mint(address(this),  _initialMintedToken * 10 ** decimals());\n        activeSystem = true;\n        currentMintAmount = (_MaxSupplies - _initialMintedToken) * 10 ** decimals();\n    }\n\n    address private Owner;\n    bool private activeSystem;\n    uint256 public immutable MAXSupply;\n    uint256 private currentMintAmount;\n\n    mapping (address Owner => IContract) public ContractStorage;\n\n    struct IContract{\n        address Authorized;\n        address stakingContract;\n        address dexContract;\n        address VotreXContract;\n        address interfaceContract;\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == Owner, \"Caller is not an Owner\"\n        );\n        _;\n    }\n\n    modifier onlyInterface() {\n        require(\n            msg.sender == ContractStorage[Owner].interfaceContract, \"Caller is not an interface\"\n        );\n        _;\n    }\n\n    modifier onlyExecutor(){\n        require(msg.sender == ContractStorage[Owner].Authorized);\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            msg.sender == ContractStorage[Owner].interfaceContract ||\n            msg.sender == Owner, \"Token - Caller is not an Authorized\"\n        );\n        _;\n    }\n\n    modifier onlyPaused() {\n        require(\n            activeSystem == false, \"System still active\"\n        );\n        _;\n    }\n\n    function customApprove(address owner, address spender, uint256 amount) external onlyInterface {\n        _approve(owner, spender, amount);\n    }\n\n    function pause() public onlyOwner {\n        require(activeSystem == true, \"System is Paused\");\n        _pause();\n        activeSystem = false;\n    }\n\n    function Activate() public onlyOwner {\n        require(activeSystem == false, \"System is Activated\");\n        _unpause();\n        activeSystem = true;\n    }\n\n    function setAutomationExecutor(address _executorAddress) external onlyOwner onlyPaused {\n        require(\n            _executorAddress != address(0),\n            \"Invalid contract address\"\n        );\n        require(\n            _executorAddress != ContractStorage[msg.sender].Authorized,\n            \"Already Registered Executor\"\n        );\n        ContractStorage[msg.sender].Authorized = _executorAddress;\n    }\n\n    function setStakingContract(address _stakingContractAddress) external onlyOwner onlyPaused {\n        require(\n            _stakingContractAddress != address(0),\n            \"Invalid contract address\"\n        );\n        require(\n            _stakingContractAddress != ContractStorage[msg.sender].stakingContract,\n            \"Already Registered Staking\"\n        );\n        ContractStorage[msg.sender].stakingContract = _stakingContractAddress;\n    }\n\n    function setDexContract(address _DEXContractAddress) external onlyOwner onlyPaused {\n        require(\n            _DEXContractAddress != address(0),\n            \"Invalid contract address\"\n        );\n        require(\n            _DEXContractAddress != ContractStorage[msg.sender].dexContract,\n            \"Already Registered DEX\"\n        );\n        ContractStorage[msg.sender].dexContract = _DEXContractAddress;\n    }\n\n    function setInterface(address _InterfaceContractAddress) external onlyOwner onlyPaused {\n        require(\n            _InterfaceContractAddress != address(0),\n            \"Invalid contract address\"\n        );\n        require(\n            _InterfaceContractAddress != ContractStorage[msg.sender].interfaceContract,\n            \"Already Registered Interface\"\n        );\n        ContractStorage[msg.sender].interfaceContract = _InterfaceContractAddress;\n    }\n\n    function setVotreXContract(address _VotreXContractAddress) external onlyOwner onlyPaused {\n        require(\n            _VotreXContractAddress != address(0),\n            \"Invalid contract address\"\n        );\n        require(\n            _VotreXContractAddress != ContractStorage[msg.sender].VotreXContract,\n            \"Already Registered VotreX\"\n        );\n        ContractStorage[msg.sender].VotreXContract = _VotreXContractAddress;\n    }\n\n    function checkBlockTime() public view returns(uint256) {\n        return block.timestamp;\n    }\n\n    function calculateHalving() public view returns (uint256) {\n        uint256 nextMint = currentMintAmount / 2;\n\n        return nextMint;\n    }\n\n    function autoMinting() public onlyExecutor{\n        require(totalSupply() < MAXSupply, \"Max Supply Reached\");\n\n        if (currentMintAmount == 0) {\n            uint256 finalMintingValue = MAXSupply - totalSupply() ;\n            _mint(address(this), finalMintingValue);\n        } else {\n            uint256 mintingValue = calculateHalving();\n            _mint(address(this), mintingValue);\n            currentMintAmount = mintingValue;\n\n        }\n    }\n\n    function mint(address to, uint256 amount) public onlyAuthorized {\n        if (msg.sender == ContractStorage[Owner].interfaceContract) {\n            require(totalSupply() < MAXSupply);\n            _mint(to, amount);\n        } else if (msg.sender == Owner) {\n            uint256 mintingValue = amount * 10**decimals();\n            require(totalSupply() < MAXSupply);\n            require(amount < 4000000);\n            _mint(to, mintingValue);\n            currentMintAmount =  currentMintAmount / 2;\n        }\n    }\n\n    function burn(uint256 value) public onlyOwner override {\n        uint256 burnedValue = value * 10**decimals();\n        _burn(address(this), burnedValue);\n    }\n\n    function getCurrentMintAmount() external view returns(uint256){\n        return currentMintAmount;\n    }\n\n    function getOwnerAddress() external view onlyOwner returns(address) {\n        return(Owner);\n    }\n\n    function _update(address from, address to, uint256 value)\n        internal\n        override(ERC20, ERC20Pausable)\n    {\n        super._update(from, to, value);\n    }\n\n}"
    },
    "contracts/VotreXTxInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./VotreXToken.sol\";\r\n\r\ncontract VotreXTXInterface {\r\n\r\n    constructor(address _tokenAddress) {\r\n        InterfaceMaster = msg.sender;\r\n        interfaceActivated = false;\r\n        vxtToken = VotreXToken(_tokenAddress);\r\n        ContractStorage[msg.sender].tokenContract = _tokenAddress;\r\n    }\r\n\r\n    // gas: 646200;\r\n\r\n    VotreXToken internal immutable vxtToken;\r\n    bool private interfaceActivated;\r\n    address private VotreXContract;\r\n    address private dexContract;\r\n    address private airdropContract;\r\n    address private stakingContract;\r\n    address private immutable InterfaceMaster;\r\n    uint256 internal immutable MaxAllowances = 15000000 * 10 ** 18;\r\n\r\n    mapping(address InterfaceMaster => IContract) public ContractStorage;\r\n    // mapping(address => uint256) public allowances;\r\n\r\n    struct IContract{\r\n        address Authorized;\r\n        address tokenContract;\r\n        address stakingContract;\r\n        address dexContract;\r\n        address VotreXContract;\r\n        address airdropContract;\r\n    }\r\n\r\n    modifier onlyActivated() {\r\n        require(interfaceActivated == true, \"Interface not Active\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPaused() {\r\n        require(interfaceActivated == false, \"Interface still Active\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStaking() {\r\n        require(\r\n            msg.sender == stakingContract,\r\n            \"Interface - Caller is not a Stake Contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == InterfaceMaster, \"Interface - Caller is not Owner!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeX() {\r\n        require(msg.sender == dexContract, \"Interface - Caller is not DexApps!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(\r\n            msg.sender == dexContract ||\r\n            msg.sender == stakingContract ||\r\n            msg.sender == VotreXContract ||\r\n            msg.sender == airdropContract,\r\n            \"Interface - Caller is not an Authorized!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event BuyVXTEvent(address Buyer, uint256 VXTTransfered);\r\n    event TransferedVXTEvent(address Receiver, uint256 VXTTransfered);\r\n    event withdrawnToken(address from, address Receiver, uint256 VXTTransfered);\r\n    event VotedEvent(address Voter, uint256 VotedPower);\r\n    event TokenDropped(address Recipient, uint256 DroppedValue);\r\n\r\n    function changeSystemState() external onlyOwner{\r\n\r\n        if (interfaceActivated == false) {\r\n            interfaceActivated = true;\r\n        } else if (interfaceActivated == true) {\r\n            interfaceActivated = false;\r\n        }\r\n\r\n    }\r\n\r\n    function isActivatedInterfaceCheck() public view returns (bool isActivatedInterface) {\r\n\r\n        return interfaceActivated;\r\n    }\r\n\r\n    function getTokenContract() external view onlyOwner returns(address){\r\n        return ContractStorage[msg.sender].tokenContract;\r\n    }\r\n\r\n    function setVotreXSys (address _VotreXContract) external onlyOwner onlyPaused{\r\n        require(\r\n            _VotreXContract != ContractStorage[msg.sender].VotreXContract,\r\n            \"Interface - Registered VotreX\"\r\n        );\r\n\r\n        require(\r\n            _VotreXContract != address(0),\r\n            \"Interface - Invalid contract address\"\r\n        );\r\n\r\n        VotreXContract = _VotreXContract;\r\n        ContractStorage[msg.sender].VotreXContract = _VotreXContract;\r\n    }\r\n\r\n    function setStakingContract (address _stakingAddress) external onlyOwner onlyPaused{\r\n        require(\r\n            _stakingAddress != ContractStorage[msg.sender].stakingContract,\r\n            \"Interface - Registered VotreX Staking\"\r\n        );\r\n\r\n        require(\r\n            _stakingAddress != address(0),\r\n            \"Interface - Invalid contract address\"\r\n        );\r\n\r\n        stakingContract = _stakingAddress;\r\n        ContractStorage[msg.sender].stakingContract = _stakingAddress;\r\n    }\r\n\r\n    function setDeX (address _dexContract) external onlyOwner onlyPaused{\r\n        require(\r\n            _dexContract != ContractStorage[msg.sender].dexContract,\r\n            \"Interface - Registered VotreX DeX\"\r\n        );\r\n\r\n        require(\r\n            _dexContract != address(0),\r\n            \"Invalid contract address\"\r\n        );\r\n\r\n        dexContract = _dexContract;\r\n        ContractStorage[msg.sender].dexContract = _dexContract;\r\n    }\r\n\r\n    function setAirdrop (address _AirdropContract) external onlyOwner onlyPaused{\r\n        require(\r\n            _AirdropContract != ContractStorage[msg.sender].airdropContract,\r\n            \"Interface - Registered VotreX Airdrop\"\r\n        );\r\n\r\n        require(\r\n            _AirdropContract != address(0),\r\n            \"Invalid contract address\"\r\n        );\r\n\r\n        airdropContract = _AirdropContract;\r\n        ContractStorage[msg.sender].airdropContract = _AirdropContract;\r\n    }\r\n\r\n    function approveTxInterface(uint32 amount) external onlyOwner {\r\n        uint256 TokenConversion = uint256(amount) * 10 ** vxtToken.decimals();\r\n\r\n        require(address(this) != address(0), \"Interface - Invalid address\");\r\n        require(TokenConversion < MaxAllowances, \"Can not approve more than limit\");\r\n\r\n        vxtToken.customApprove(address(vxtToken), address(this), TokenConversion);\r\n    }\r\n\r\n    function approveVotreX(uint256 amount) external onlyAuthorized onlyActivated{\r\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\r\n\r\n        require(msg.sender != address(0), \"Interface - VotreX Address not set\");\r\n        require(TokenConversion < MaxAllowances, \"Can not approve more than limit\");\r\n\r\n        vxtToken.customApprove(msg.sender, address(this), TokenConversion);\r\n    }\r\n\r\n    function approveAirdrop(uint256 amount) external onlyAuthorized onlyActivated{\r\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\r\n\r\n        require(address(this) != address(0), \"Interface - Invalid address\");\r\n        require(TokenConversion < MaxAllowances, \"Can not approve more than limit\");\r\n\r\n        vxtToken.customApprove(msg.sender, address(this), TokenConversion);\r\n    }\r\n\r\n    function approveStaking(uint256 amount) external onlyAuthorized onlyActivated{\r\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\r\n\r\n        require(msg.sender != address(0), \"Interface - Staking Address not set\");\r\n        require(amount < MaxAllowances, \"Interface - Can not approve more than limit\");\r\n\r\n        vxtToken.customApprove(msg.sender, address(this), TokenConversion);\r\n    }\r\n\r\n    function approveDeX(uint256 amount) external virtual onlyAuthorized onlyActivated{\r\n        uint256 TokenConversion = amount * 10 ** vxtToken.decimals();\r\n\r\n        require(msg.sender != address(0), \"Interface - DeX Address not set\");\r\n        require(TokenConversion < MaxAllowances, \"Interface - Can not approve more than limit\");\r\n\r\n        vxtToken.customApprove(msg.sender, address(this), TokenConversion);\r\n    }\r\n\r\n    function checkApprovalLimit(address _ContractAddress) external view returns (uint256){\r\n        if(_ContractAddress == ContractStorage[msg.sender].VotreXContract){\r\n            return (\r\n                vxtToken.allowance(\r\n                    ContractStorage[msg.sender].VotreXContract, address(this)\r\n                )\r\n            );\r\n        }\r\n        else if(_ContractAddress == ContractStorage[msg.sender].dexContract){\r\n            return (\r\n                vxtToken.allowance(\r\n                    ContractStorage[msg.sender].dexContract, address(this)\r\n                )\r\n            );\r\n        }\r\n        else if(_ContractAddress == ContractStorage[msg.sender].stakingContract){\r\n            return (\r\n                vxtToken.allowance(\r\n                    ContractStorage[msg.sender].stakingContract, address(this)\r\n                )\r\n            );\r\n        }\r\n        else if(_ContractAddress == ContractStorage[msg.sender].airdropContract){\r\n            return (\r\n                vxtToken.allowance(\r\n                    ContractStorage[msg.sender].airdropContract, address(this)\r\n                )\r\n            );\r\n        }\r\n        else {\r\n            return (404);\r\n        }\r\n    }\r\n\r\n    function checkBalance(address account) external view virtual onlyActivated returns (uint256) {\r\n        return vxtToken.balanceOf(account);\r\n    }\r\n\r\n    function balanceTx(address _Recipient, uint256 _value) external onlyOwner{\r\n        uint256 vxtNominalTransfer = _value * 10 ** vxtToken.decimals();\r\n\r\n        if (\r\n            _Recipient == ContractStorage[msg.sender].VotreXContract\r\n        ) {\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\r\n            )\r\n            {\r\n                vxtToken.transferFrom(address(vxtToken), VotreXContract, vxtNominalTransfer);\r\n            } else {\r\n                vxtToken.customApprove(msg.sender, _Recipient, vxtNominalTransfer);\r\n                vxtToken.customApprove(msg.sender, address(this), vxtNominalTransfer);\r\n\r\n                vxtToken.transferFrom(address(vxtToken), VotreXContract, vxtNominalTransfer);\r\n            }\r\n        } else if (\r\n            _Recipient == ContractStorage[msg.sender].dexContract\r\n        ) {\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\r\n            )\r\n            {\r\n                vxtToken.transferFrom(address(vxtToken),dexContract, vxtNominalTransfer);\r\n            }\r\n            else {\r\n                vxtToken.customApprove(msg.sender, _Recipient, vxtNominalTransfer);\r\n                vxtToken.customApprove(msg.sender, address(this), vxtNominalTransfer);\r\n\r\n                vxtToken.transferFrom(address(vxtToken), dexContract, vxtNominalTransfer);\r\n            }\r\n        } else if (_Recipient == InterfaceMaster) {\r\n            require(_value < 4000000, \"Interface - Transfer limit Reached\");\r\n            require(msg.sender == InterfaceMaster, \"Interface - Not Authorized\");\r\n\r\n            // Case for Interface Master\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n            ){\r\n                vxtToken.transferFrom(address(vxtToken), address(InterfaceMaster), vxtNominalTransfer);\r\n            } else {\r\n                vxtToken.customApprove(address(vxtToken), address(this), vxtNominalTransfer);\r\n                vxtToken.customApprove(address(vxtToken), InterfaceMaster, vxtNominalTransfer);\r\n\r\n                vxtToken.transferFrom(address(vxtToken), msg.sender, vxtNominalTransfer);\r\n\r\n                emit TransferedVXTEvent(msg.sender, vxtNominalTransfer);\r\n            }\r\n        }else if (\r\n            _Recipient != InterfaceMaster||\r\n            _Recipient != ContractStorage[msg.sender].dexContract ||\r\n            _Recipient != ContractStorage[msg.sender].VotreXContract\r\n        ){\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function VotreXTx(\r\n        address _Recipient,\r\n        uint256 _value\r\n    )\r\n        external\r\n        virtual\r\n        onlyAuthorized\r\n        onlyActivated\r\n    {\r\n        uint256 vxtNominalTransfer = _value * 10 ** vxtToken.decimals();\r\n\r\n        if (msg.sender == VotreXContract) {\r\n            // Case for VotreX\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n            )\r\n            {\r\n                vxtToken.transferFrom(_Recipient, msg.sender, vxtNominalTransfer);\r\n            }\r\n            else {\r\n                vxtToken.customApprove(msg.sender, _Recipient, vxtNominalTransfer);\r\n                vxtToken.customApprove(msg.sender, address(this), vxtNominalTransfer);\r\n                vxtToken.customApprove(_Recipient, address(this), vxtNominalTransfer);\r\n\r\n                vxtToken.transferFrom(msg.sender, _Recipient, vxtNominalTransfer);\r\n\r\n                emit TransferedVXTEvent(msg.sender, vxtNominalTransfer);\r\n            }\r\n        } else if (msg.sender == dexContract) {\r\n            // Case for DeX\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= _value\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n            )\r\n            {\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\r\n            }\r\n            else {\r\n                vxtToken.customApprove(msg.sender, _Recipient, _value);\r\n                vxtToken.customApprove(msg.sender, address(this), _value);\r\n\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\r\n\r\n                emit BuyVXTEvent(msg.sender, _value);\r\n            }\r\n        } else if (msg.sender == stakingContract) {\r\n            // Case for Staking Contract\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= _value\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n            ){\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value); \r\n            }\r\n            else {\r\n                vxtToken.customApprove(msg.sender, _Recipient, _value);\r\n                vxtToken.customApprove(msg.sender, address(this), _value);\r\n                vxtToken.customApprove(_Recipient, address(this), _value);\r\n\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\r\n\r\n                emit withdrawnToken(msg.sender, _Recipient, _value);\r\n            }\r\n        } else if (msg.sender == airdropContract) {\r\n            // Case for Airdrop\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= _value\r\n            ){\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\r\n            }\r\n            else {\r\n                vxtToken.customApprove(msg.sender, _Recipient, _value);\r\n                vxtToken.customApprove(msg.sender, address(this), _value);\r\n\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\r\n\r\n                emit TokenDropped(_Recipient, _value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function VoteTx(address _Sender, uint256 _value) external onlyAuthorized onlyActivated{\r\n        require (msg.sender == VotreXContract, \"Interface - Not VotreX\");\r\n\r\n        uint256 vxtNominalTransfer = _value * 10 ** vxtToken.decimals();\r\n\r\n        if (\r\n            vxtToken.allowance(msg.sender, address(this)) >= vxtNominalTransfer\r\n            &&\r\n            vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n        ) {\r\n            vxtToken.transferFrom(_Sender, msg.sender, vxtNominalTransfer);\r\n        } else {\r\n            vxtToken.customApprove(_Sender, address(this), vxtNominalTransfer);\r\n\r\n            vxtToken.transferFrom(_Sender, msg.sender, vxtNominalTransfer);\r\n\r\n            emit VotedEvent(msg.sender, vxtNominalTransfer);\r\n        }\r\n    }\r\n\r\n    function printVXT(address _recipient, uint256 _rewardValue) external onlyAuthorized onlyActivated{\r\n        vxtToken.mint(_recipient, _rewardValue);\r\n    }\r\n\r\n    function totalSupplies() external view returns(uint256) {\r\n        return vxtToken.totalSupply();\r\n    }\r\n\r\n    function Stake(\r\n        bool isStaking,\r\n        address _Recipient,\r\n        uint256 _value\r\n    )\r\n        external\r\n        onlyAuthorized\r\n        onlyActivated\r\n    {\r\n        if (\r\n            msg.sender == stakingContract\r\n            &&\r\n            isStaking == true\r\n        ) {\r\n            // Case for Staking\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= _value\r\n                &&\r\n                vxtToken.allowance(msg.sender, _Recipient) >= _value\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n                &&\r\n                vxtToken.allowance(msg.sender, _Recipient) >= MaxAllowances\r\n                )\r\n            {\r\n                vxtToken.transferFrom(_Recipient, msg.sender, _value);\r\n            } else {\r\n                // Case 4: Approve and transfer\r\n                vxtToken.customApprove(_Recipient, address(this), _value);\r\n                vxtToken.customApprove(msg.sender, address(this), _value);\r\n                vxtToken.customApprove(_Recipient, msg.sender, _value);\r\n\r\n                vxtToken.transferFrom(_Recipient, msg.sender, _value);\r\n            }\r\n        } else if (\r\n            msg.sender == stakingContract\r\n            &&\r\n            isStaking == false\r\n        ) {\r\n            // Case for unStaking & Reward Distribution\r\n            if (\r\n                vxtToken.allowance(msg.sender, address(this)) >= _value\r\n                &&\r\n                vxtToken.allowance(msg.sender, _Recipient) >= _value\r\n                &&\r\n                vxtToken.allowance(msg.sender, address(this)) >= MaxAllowances\r\n                &&\r\n                vxtToken.allowance(msg.sender, _Recipient) >= MaxAllowances\r\n            )\r\n            {\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\r\n            }\r\n            else {\r\n                vxtToken.customApprove(msg.sender, _Recipient, _value);\r\n\r\n                vxtToken.transferFrom(msg.sender, _Recipient, _value);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 120
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}